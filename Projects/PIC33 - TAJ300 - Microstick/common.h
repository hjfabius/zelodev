#ifndef __COMMON_H__
	#define __COMMON_H__ 


	#if defined(__dsPIC33F__)
		#include "p33fxxxx.h"
	#elif defined(__PIC24H__)
		#include "p24hxxxx.h"
	#endif

	#include "defs.h"


	#define APPLICATION_VERSION								302

	
	//#define OSCILLATOR_FREQUENCY	80000000   /* Fosc = 80Mhz */
	#define OSCILLATOR_FREQUENCY	8000000    /* 7.5 us = 265KHz: Misurata con oscilloscopio su T1 */
	#define SPI_MANUAL
	#define MM_IN_ENCODER 		1
	#define MARK_TYPE_AB
	#define MARK_STARING_POINT 4090

	#define RP_QEA					12
	#define RP_QEB					13
	#define RP_IND					14
	#define RP_S1					5
	#define RP_S2					5
	#define RP_DDQUE				3
	#define RP_SDI1					6
	
	


	#define ENCODER_PERIOD			1024  
	
	#define PIN_DIRECTION_A			PORTBbits.RB15 /* To substitute on the new schema */
	#define PIN_DIRECTION_R			PORTBbits.RB15 /* To substitute on the new schema */
	#define PIN_DIRECTION_T			PORTBbits.RB15 /* To substitute on the new schema */
	#define PIN_DIRECTION_O			PORTBbits.RB15 /* To substitute on the new schema */
	#define PIN_DIRECTION_I			PORTBbits.RB15 /* To substitute on the new schema */
	#define PIN_DIRECTION_D			PORTBbits.RB15 /* To substitute on the new schema */
		
	
	#define PIN_LED					PORTBbits.RB15
	#define PIN_LED_GREEN			PORTAbits.RA4
	#define PIN_LED_RED				PORTBbits.RB2 

	#define PIN_GATE				PORTAbits.RA1
	#define PIN_S1					PORTBbits.RB5
	#define PIN_S2					PORTBbits.RB5
	#define PIN_ENCODER_A			PORTBbits.RB12
	#define PIN_ENCODER_B			PORTBbits.RB13
	#define PIN_ENCODER_0			PORTBbits.RB14
	

	
	
	//Used in communication with ST7					Z80		PIC		Direction	ST7		Meaning	
	#define PIN_DDQUE				PORTBbits.RB3	/*  TASDA	DDQUE		<--		DDQUE	When ST7 wants to start communication set this bit (handled with interrupt) */
	#define PIN_DDCK				PORTBbits.RB4	/* 	DDCK	SCKx		-->		DDCK	Clock generated by PIC once communication is started */
	#define PIN_DDOUT				PORTBbits.RB6	/* 	TASA	SDIx		<--		DDOUT	Data from ST7 to PIC */
	#define PIN_DDIN				PORTBbits.RB7	/* 	DDIN	SDOx		-->		DDIN	Data from PIC to ST7 */
	#define PIN_DDASK				PORTBbits.RB9	/* 	OUTPA1	DDASK		-->		DDASK	When PIC wants to start communication set this bit */
	
	#define PULSE_QEI 					0
	#define PULSE_T2					1

	#define SIGNAL_COUNT 				2
	#define SIGNAL_PHASE_COUNT 			8
	//#define TOTAL_SIGNAL_COUNT			2  /*Max(SIGNAL_COUNT,SIGNAL_PHASE_COUNT)*/
	
	#define ENCODER_AREA_PHASE_STOP		100
	#define ENCODER_AREA_IN_GATE_1		101
	#define ENCODER_AREA_IN_GATE_2		102
	#define ENCODER_AREA_OUT_OF_GATE	103

	//#define ENCODER_AREA_STEP_PHASE_MC  103
	
	//#define STEP_PHASE_MC				200
	#define STEP_PHASE_MM				201
	#define STEP_SIGNAL_ACQUISITION		203
	#define STEP_READY_FOR_CALCULATION	204

	
	#include "spi.h"
	#include "eeprom.h"
	#include "parameters.h"
	#include "sti.h"
	#include "sni.h"
	#include "init.h"
	#include "interrupt.h"
	#include "scanningHeadSignal.h"
	#include "label.h"
	#include "navigation.h"
	#include "display_macros.h"
	#include "display.h"
	//#include "main.h"
	#include "window.h"
	#include "screen.h"
	#include "display_application.h"	
	
	extern volatile WORD m_woEncoderPosition;
	extern volatile BYTE m_byS1;
	
	extern volatile BYTE m_arbyScanningHeadSignal[ENCODER_PERIOD/4];	
	extern volatile WORD m_woCurrentQEIPulseLength;
	extern volatile WORD m_arwoQEIPulseLengthStart[SIGNAL_COUNT];
	extern volatile WORD m_arwoQEIPulseLengthEnd[SIGNAL_COUNT];
	extern volatile WORD m_arwoSignalStart[2][SIGNAL_COUNT];
	extern volatile WORD m_arwoSignalEnd[2][SIGNAL_COUNT];
	extern volatile WORD m_arwoGateStart[1][SIGNAL_COUNT];
	extern volatile WORD m_arwoGateEnd[1][SIGNAL_COUNT];
	extern volatile WORD m_arwoSignalPhaseStart[SIGNAL_PHASE_COUNT];
	extern volatile WORD m_arwoSignalPhaseEnd[SIGNAL_PHASE_COUNT];
	extern 		  double m_ardblSignalStart[SIGNAL_COUNT];		//4X Signal Start based on encoder position (with decimals coming from timers)
	extern 		  double m_ardblSignalEnd[SIGNAL_COUNT];		//4X Signal End based on encoder position  (with decimals coming from timers)
	extern 		  double m_ardblSignalMiddle[SIGNAL_COUNT];		//Signal Middle Point (Start+End/2)
	extern 		  double m_ardblDistanceLong[SIGNAL_COUNT-1];
	extern 		  double m_ardblDistanceTran[SIGNAL_COUNT-1];
	extern 		  double m_ardblReferenceLong[SIGNAL_COUNT-1];
	extern 		  double m_ardblErrorLong[SIGNAL_COUNT-1];
	extern 		  double m_ardblErrorTran[SIGNAL_COUNT-1];
	extern 		  double m_dblSpeedFactor;	 					
	extern		  double m_dblMillimeterInEncoderPulse;
	extern volatile BYTE m_ucSteps;
	extern volatile BYTE m_ucEncoderArea;
	extern			BYTE m_ucSignalPhasePointer;
	extern  		BYTE m_arycSignalPositionInMarks[SIGNAL_COUNT];

	
	

	#define MATRIX_DISPLAY_PAGES_WIDTH 						32
	#define CPU_8Mhz
	#define DISPLAY_922_KEYBOARD

/*****************************************************************************/
// Variables declaration
/*****************************************************************************/
	static const unsigned char mc_byApplicationVersion		= APPLICATION_VERSION;

/*****************************************************************************/
// Functions declaration
/*****************************************************************************/
	#define _bset(A, B)		 	 (A |= (0x0001<<(B)))
	#define _bres(A, B)		 	 (A &= ~(0x0001<<(B)))
	#define _btst(A, B)		 	 ((A) & (0x0001<<(B)))
	#define _switch(A, B)		 if(_btst(A, B)){_bres(A, B);}else{_bset(A, B);}
	#define _peak(A, B)			 _bres(A, B);Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();Nop();_bset(A, B);
	#define EnableInterrupts() 		asm ("NOP")  
	#define DisableInterrupts()		asm ("NOP") 
	#define	 true 				 1
	#define	 false 				 0

	void sleepSec(WORD a_uintSec);
	void sleep(LWORD a_uintMilliSec);
	void sleepForIRQ(LWORD a_uintMilliSec);
	void sleepFix(void);
	void memcpyFull(STRING a_strTo, STRING a_strFROM, BYTE a_byLength);
	void formatNumber(WORD a_woValue, BYTE a_byNumDigit, BYTE a_byNumDecimal, BYTE * a_byString);
	void formatNumberLong(LWORD a_lwoValue, BYTE a_byNumDigit, BYTE a_byNumDecimal, BYTE * a_byString);
	void formatNumberBinary(WORD a_woValue,BYTE * a_byString);
	WORD getBoundedValue(WORD * a_woValue, SWORD a_swoChange, WORD * a_woMax, WORD *a_woMin);
	WORD BCDtoHEX(LWORD a_lwoValue);
	BYTE memcpyCustom(STRING a_strTo, STRING a_strFROM, BYTE a_byLength);

	WORD convertEncoder(WORD a_woEncoder);
	
#endif
